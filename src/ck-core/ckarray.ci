module CkArray {
  extern module CkReduction;
  extern module CkLocation;
  extern module CkArrayReductionMgr;

  readonly bool _isAnytimeMigration;
#if USE_MIRROR
  readonly CProxy_MirrorUpdate MirrorProxy;

  mainchare MirrorInit {
      entry MirrorInit(CkArgMsg *m);
  }

  group [migratable] MirrorUpdate {
      entry MirrorUpdate(void);
      entry void update(int id1, int id2);
  };
#endif

  group [migratable] CkArray : CkReductionMgr {
	entry CkArray(CkArrayOptions opts, CkMarshalledMessage ctorMsg, CkNodeGroupID nodereductionProxy);
	//Insertion
	entry void insertElement(CkMessage *);
	entry void remoteBeginInserting(void);
	entry void remoteDoneInserting(void);
	//Broadcast
	entry void sendBroadcast(CkMessage *);
	entry void recvBroadcast(CkMessage *);
	entry void recvBroadcastViaTree(CkMessage *);
	entry [expedited] void sendExpeditedBroadcast(CkMessage *);
	entry [expedited] void recvExpeditedBroadcast(CkMessage *);

        entry void ckDestroy();
  };

  PUPable CkVerboseListener;
  PUPable CkArrayBroadcaster;
  PUPable CkArrayReducer;

  // COMLIB HACK
  //PUPable ComlibArrayListener;

  initproc void _ckArrayInit(void);

  array [none] ArrayElement {
    entry ArrayElement();
    //Calls destructor:
    entry void ckDestroy(void);
    entry void recvBroadcast(CkMessage *);
    // CMK_MEM_CHECKPOINT
    entry void inmem_checkpoint(CkArrayCheckPTReqMessage *);
    // _PIPELINED_ALLREDUCE_
    entry void defrag(CkReductionMsg*);
#if USE_MIRROR
    entry void recvSyncMirrorData(CkMirrorSyncMessage *msg);
    entry void syncMirror(CkCallback& cb);
    entry void recvAck();
#endif
  };

  message CkCreateArrayAsyncMsg {
    char ctorPayload[];
  };

  message CkArrayCreatedMsg {
    CkArrayID aid;
  };

};
