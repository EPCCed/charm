#ifndef __CK_ACCEL_H__
#define __CK_ACCEL_H__

#include <list>
#include <map>

#include "charm++.h"
#include "ckaccel_common.h"
#include "ckaccel.decl.h"

// Forward declare the AccelManager class
class AccelManager;

extern void hapi_poolFree(void *);
extern void *hapi_poolMalloc(int size);
////////////////////////////////////////////////////////////////////////////////
// Accelerator manager configuration macros

#define ACCEL_CONTRIB_TRIGGERED_TIMEOUT      (0.250)  // 250 ms (should be long, meant as a safety net)
#define ACCEL_CONTRIB_NONTRIGGERED_TIMEOUT   (0.005)  //   5 ms (should be short, likely to be used)

#define ACCEL_AEMs_PER_GPU_KERNEL   (512)  // The maximum number of AEM invocations per batch

// TODO : Make this adjustable via the command-line, match up with
//   load balancing period, etc. instead of being a hardcoded value
#define ACCELMGR_IDLE_PERIOD        (2.0)  // (Units: seconds) Minimum time to accumulate idle/busy time before notifying the strategy

#define ACCELMGR_IDLE_NOTIFY_TYPE_UNKNOWN      (-1)
#define ACCELMGR_IDLE_NOTIFY_TYPE_BEGIN        ( 0)
#define ACCELMGR_IDLE_NOTIFY_TYPE_END          ( 1)
#define ACCELMGR_IDLE_NOTIFY_TYPE_PERIODIC     ( 2)

#define ACCELMGR_FLAGMASK_AUTO_MEASURE_PERF  (0x01)

#define ACCELMGR_KERNEL_TIME_IDLE              (0)
#define ACCELMGR_KERNEL_TIME_BUSY              (1)


////////////////////////////////////////////////////////////////////////////////
// Error enumeration

enum AccelError { ACCEL_SUCCESS = 0,
                  ACCEL_ERROR_UNKNOWN,
                  ACCEL_ERROR_INVALID_PARAMETER,
                  ACCEL_ERROR_OUT_OF_MEMORY,
                  ACCEL_ERROR_INVALID_STRATEGY
                };


////////////////////////////////////////////////////////////////////////////////
// Declare the external functions that are generated by charmxi

extern void kernelSetup(int, void*, int, void*, void*, int, void**, void**);
extern void kernelCleanup(void*, void*);


////////////////////////////////////////////////////////////////////////////////
// AccelSharedLookup : A class that is essentially a hash table that is used to
//   store and lookup offsets to shared buffers being used for GPGPU batching.
// NOTE: Since there is a maximum number of AEMs that can be added to a batch
//   (on the order of 512), this hash table does not increase its number of
//   initial bins (on the order of 256).  If this relationship changes at some
//   point in the future, then this hash table implementation should be updated
//   to reflect that change.

// Compile-time constants related to AccelSharedLookup
#define ACCEL_SHARED_LOOKUP_INIT_LEN   (1024)  // # of records which are placed in the hash table (i.e. is a pool to avoid malloc calls)
#define ACCEL_SHARED_LOOKUP_GROW_LEN   (1024)
#define ACCEL_SHARED_LOOKUP_TABLE_LEN  ( 256)  // # of hash table entries - NOTE: This value depends on the hash function
#define ACCEL_INVALID_OFFSET           (  -1)

// Record used for each entry in an AccelSharedLookup hash table
typedef struct __accel_shared_lookup_record {
  struct __accel_shared_lookup_record *next;
  void *ptr;
  int ptrLen;
  int offset;
} AccelSharedLookupRecord;

// The AccelSharedLookup class, used to track shared local parameter (buffer) pointers
//   during the invocation of AEMs
class AccelSharedLookup {

 private:

  AccelSharedLookupRecord *recordList;   // An array of records that are inserted into the hash table (pooling)
  int recordListLen;                     // The number of records in recordList in use
  int recordListLen_max;                 // The total number of records in the recordList

  AccelSharedLookupRecord **recordTable; // An array of points, serving as the hash table (indexed via the hash functions below)

  void initialize();
  void cleanup();

  static int hash(const AccelSharedLookupRecord * const sRec);  // Hashing function
  static int hash(const void * const ptr, const int ptrLen);    // Hashing function

 public:

  AccelSharedLookup();
  ~AccelSharedLookup();

  void reset();   // Reset (empty) the hash table

  int lookupOffset(const void * const ptr, const int ptrLen);
  void insertOffset(const void * const ptr, const int ptrLen, const int offset);
};


////////////////////////////////////////////////////////////////////////////////
// AccelCallbackStruct
//   This class is essentially the record that is used to track information
//   related to batches of AEMs on the GPGPU.  It is filled in during the batch
//   process and then used to process the generated callback once the batch
//   completes.

typedef struct __accel_callback_struct {

  void *wr;   // Pointer to related work request for HybridAPI
  void *di;   // Pointer to related data info for HybridAPI

  void **impl_objs;  // Array of pointers to chare objects (len: numElements_count)

  AccelSharedLookup *sharedLookup;  // Data structure to hold shared offsets in wrData

  double contribStartTime;   // Time variables for displaying user events in Projections
  double issueTime;          // NOTE: if < 0, batch has not been issued yet
  double callbackStartTime;
  double lastContribTime;    // The last time an AEM was contributed to this batch

  void *wrData;       // Data buffer containing all data for kernel
  int wrDataLen;      // Length of useful data in wrData buffer
  int wrDataLen_max;  // Actual size of wrData buffer

  int numElements;           // Number of chares of the associated type
  int numElements_count;     // Number of chares involved in this kernel

  int abandonFlag;   // Flag indicating that the batch should be abandoned (!= 0 is set)

  int funcIndex;           // The function index of the AEMs within this batch (should all match)
  void *callbackPtr;       // A pointer to the callback function
  int *numSplitsSubArray;  // A pointer (into wrData) that holds the list of numSplits when invocations don't all have the same number of splits
  int threadCount;         // The number of threads associated with this batch

} AccelCallbackStruct;


////////////////////////////////////////////////////////////////////////////////
// AccelDecision
//   The decision structure that is returned when a decision request is made of
//   the accelerator manager.  The fields indicate what the generated code
//   (in charmxi) should do with an AEM invocation.

enum AccelIssueFlag { ACCEL_ISSUE_FALSE = 0,
                      ACCEL_ISSUE_TRUE = -1
                    };

enum AccelDeviceType { ACCEL_DEVICE_UNKNOWN = -1,
                       ACCEL_DEVICE_HOST = 0,
                       ACCEL_DEVICE_SPE,
                       ACCEL_DEVICE_GPU_CUDA,
                       ACCEL_DEVICE_HOST_DELAY,
                       ACCEL_DEVICE_MIC,
                       ACCEL_NUM_DEVICE_TYPES
                     };

#define ACCEL_DEVICE_INDEX_UNKNOWN  (-1)  // NOTE: Used to indicate an invalid AccelDecision::deviceIndex

typedef struct __accel_decision {
  enum AccelIssueFlag issueFlag;
  enum AccelIssueFlag issueDelayedFlag;
  enum AccelDeviceType deviceType;
  int deviceIndex;
} AccelDecision;


////////////////////////////////////////////////////////////////////////////////
// AccelStrategyType and Strategy Parameters/Macros
//   An enumeration indicating the accelerator load balancing strategies
//   available to applications.

enum AccelStrategyType { ACCEL_STRATEGY_UNKNOWN = -1,
                         ACCEL_STRATEGY_ALL_ON_DEVICE = 0,
                         ACCEL_STRATEGY_ALL_ON_HOST,
                         ACCEL_STRATEGY_PERCENT_DEVICE,
                         ACCEL_STRATEGY_STEP,
                         ACCEL_STRATEGY_ADJUST_BUSY,
                         ACCEL_STRATEGY_SAMPLING,
                         ACCEL_STRATEGY_PROFILER,
                         ACCEL_STRATEGY_BASE_LOAD_PROFILER,
			 ACCEL_STRATEGY_GREEDY,
			 ACCEL_STRATEGY_CRAWLER_MASTER,
			 ACCEL_STRATEGY_CRAWLER_SLAVE,
                         ACCEL_NUM_STRATEGY_TYPES,
                         ACCEL_STRATEGY_DEFAULT = ACCEL_STRATEGY_ADJUST_BUSY
                       };

#define ACCEL_STRATEGY_ADJUST_STEP_STEPSIZE  (0.025f)

#define ACCEL_STRATEGY_ADJUST_PERF_CENTRAL (1)  // Set this if using PERF above and want a centralized approach

#define ACCEL_STRATEGY_ADJUST_BUSY_HOST_BIAS_FACTOR    ( 100.0f/100.0f  )
#define ACCEL_STRATEGY_ADJUST_BUSY_MARGIN_FACTOR       (        1.05f   )
#define ACCEL_STRATEGY_ADJUST_BUSY_MIN_STEP            (        0.0025f )
#define ACCEL_STRATEGY_ADJUST_BUSY_MAX_STEP            (        0.20f   )
#define ACCEL_STRATEGY_ADJUST_BUSY_STEP_MULTIPLIER     (        5.0f    )

// DMK - NOTE | TODO | FIXME - Right now the data structure is a dense array so
// it can be indexed into quickly.  However, may want to change this in the
// future to avoid the memory costs of having a dense array if the performance
// data collect is actually sparse.
#define ACCELMGR_PERFVALS_RESOLUTION            ( 200 )   // NOTE:  100% / <this> = resolution
#define ACCELMGR_PERFVALS_SAMPLE_SIZE           (  15 )   // # of most recent samples used to calc avg
#define ACCELMGR_PERFVALS_MIN_NEW_SAMPLE_COUNT  (   5 )   // Min # samples before percentDevice update
#define ACCELMGR_PERCENT_DEVICE_PENDING_LEN     (  10 )   // max # of new # percentDevice values to try

#define ACCEL_PROFILE_MIN_NUM_NEW_SAMPLES    (10)

#define ACCEL_CRAWLER_MIN_NEW_SAMPLES           (      3 )
#define ACCEL_CRAWLER_INIT_PERCENT_DEVICE_STEP  ( 0.005f )
#define ACCEL_CRAWLER_MIN_PERCENT_DEVICE_STEP   ( 0.002f )
#define ACCEL_CRAWLER_MAX_PERCENT_DEVICE_STEP   ( 0.200f )


////////////////////////////////////////////////////////////////////////////////
// AccelDelayCallData
//   The data structure used as a record for delayed AEM invocations bound for
//   the host core.

typedef struct _accel_delay_call_data {
  void *objPtr;                                      // Pointer to the chare object
  void (*funcPtr)(struct _accel_delay_call_data*);   // Pointer to the function that will resume the AEM invocation (function generated by charmxi)
  int funcIndex;                                     // The function index of the AEM invocation
  void *passedParams;                                // A pointer to a generated data structure containing passed parameters for the AEM invocation (generated in charmxi)
} AccelDelayCallData;



////////////////////////////////////////////////////////////////////////////////
// AEMRecord
//   A data structure that contains information related to each AEM declaration
//   (or AEM type) within the application.

typedef struct __accelerated_entry_method_record {

  int funcIndex;            // The function index for this AEM type

  int isTriggered;          // Flag indicating this is a triggered AEM or not
  int isSplittable;         // Flag indicating this is a splittable AEM or not

  int checkInCount;         // For triggered AEMs: A count of the number of invocations that have been issued so far in the 'one-to-one sets'
  int numLocalElements;     // For triggered AEMs: A count of the local objects of the chare class associated with this AEM type

  //AccelStrategyType strategyType;
  void *strategyVars;       // Pointer to strategy-specific variables for each AEM type

  float hostToKernelRatio;  // A variable indicating the average host time / average kernel time to execute this type of AEM (filled in by KernelRation profiler; -1.0f = unset)
  float avgHostTime;        // The average amount of time to execute this type of AEM on the host core

  AccelCallbackStruct *currentCbStruct;  // A pointer to the AccelCallbackStruct (batch) that AEMs of this type are currently being collected into

  std::list<AccelDelayCallData*> *delayedCalls;  // A list of delayed AEM invocations of this AEM type that are bound for the host core

} AEMRecord;


////////////////////////////////////////////////////////////////////////////////
// AccelStrategy
//   The base class for all of the accelerator load balancing strategies.

class AccelStrategy {

 public:

  AccelStrategy() { }
  virtual ~AccelStrategy() { }

  // The decision function that is called from within the generated host code and used to
  //   direct the execution of each AEM invocation.  The strategy implemented within a child
  //   class should be reflected in the decisions that are 'returned' from this function.
  virtual AccelError decide(int funcIndex,            // The type of AEM being considered
                            AEMRecord *record,        // The record for the AEM type
                            AccelDecision &decision,  // A decision data structure to be filled in by the decide function
                            void *objPtr,             // A pointer to the object the AEM is being executed on
                            AccelManager* manager     // A pointer to the accelerator manager
                           ) = 0;

  // A function that returns the strategy type (enum AccelStrategyType)
  virtual int getStrategyType() = 0;

  // Function the accelerator manager uses to notify the strategy of a change in the host core's
  //   idle status (if idle data is reset, a minimum period of time will elapsed during which the
  //   accelerator manager does not notify the strategy of changes)
  virtual void notifyIdle(AccelManager *manager) { }

  // A function that the accelerator manager uses to notify the strategy when a periodic sample is
  //   generated (e.g. when measuring the amount of time between periodic points in the application)
  virtual void periodicSample(double value, AccelManager *manager) { }

  // A function that notifies the strategy of the timing for an AEM invocation related to the
  //   passed in AEMRecord as it is executed on the host core
  virtual void userHostCodeTiming(AEMRecord *record, double startTime, double endTime) { }

  // A function that notifies the strategy when a load balancing step has completed
  virtual void notifyLBFinished() { }

  // A function that indicates whether or not this strategy is a centralized strategy or not
  //   (i.e. instances of the runtime system across the host cores pass information to one
  //   another in order to implement the strategy)
  virtual int isCentralized() { return 0; }

  // Functions that are used by the accelerator manager when the strategy is created/destroyed
  //   that allows the strategy to create a data structure that will be associated with the AEM
  //   type's AEMRecord and used to hold values between calls to the strategy's decide function
  virtual void* allocStrategyVars() { return NULL; }
  virtual void freeStrategyVars(void* vars) { }

  virtual int isSafeToRemove() { return 0; }
  virtual void aboutToAdd(AccelManager *manager) { }
  virtual void aboutToRemove(AccelManager *manager) { }

  virtual int isPercentDevicePassable() { return 0; }
  virtual float getPassedPercentDevice(AEMRecord *record) { return 0.0f; }

  virtual int acceptsPercentDevicePassable() { return 0; }
  virtual void setPassedPercentDevice(AEMRecord *record, float pd) { }

  virtual void printConfig(FILE *fout = stdout) = 0;
};


class AccelStrategy_AllOnDevice : public AccelStrategy {

 public:

  AccelStrategy_AllOnDevice() { }
  virtual ~AccelStrategy_AllOnDevice() { }

  virtual AccelError decide(int funcIndex,
                            AEMRecord *record,
                            AccelDecision &decision,
                            void *objPtr,
                            AccelManager* manager
                           );

  virtual int getStrategyType() { return ACCEL_STRATEGY_ALL_ON_DEVICE; }

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: All On Device\n", CkMyPe());
  };
};


class AccelStrategy_AllOnHost : public AccelStrategy {

 public:

  AccelStrategy_AllOnHost() { }
  virtual ~AccelStrategy_AllOnHost() { }

  virtual AccelError decide(int funcIndex,
                            AEMRecord *record,
                            AccelDecision &decision,
                            void *objPtr,
                            AccelManager* manager
                           );

  virtual int getStrategyType() { return ACCEL_STRATEGY_ALL_ON_HOST; }

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: All On Host\n", CkMyPe());
  };
};


class AccelStrategy_PercentDevice : public AccelStrategy {

 private:

  struct Variables {
    float percentDevice;
    int deviceCount;
    int hostCount;
    int deviceTarget;
    int hostTarget;
    int assigningFlag;
  };

  float percentDevice;
  int staticAssignFlag;

  int newSampleCount;

  void initialize(float pd = 1.0f, int saf = 0) {
    setPercentDevice(pd);
    setStaticMode(saf);
    resetNewSampleCount();
  }

  AccelError decideStatic(int funcIndex,
                          AEMRecord *record,
                          AccelDecision &decision,
                          void *objPtr,
                          AccelManager* manager
                         );

  AccelError decideDynamic(int funcIndex,
                           AEMRecord *record,
                           AccelDecision &decision,
                           void *objPtr,
                           AccelManager* manager
                          );

 protected:

  float getPercentDevice() { return percentDevice; }

  int getNewSampleCount() { return newSampleCount; }
  void resetNewSampleCount();
  void incrementNewSampleCount(AccelManager *manager);

 public:

  AccelStrategy_PercentDevice() { initialize(); }
  AccelStrategy_PercentDevice(int saf) { initialize(1.0f, saf); } //setPercentDevice(1.0f); resetNewSampleCount(); }
  AccelStrategy_PercentDevice(float pd, int saf) { initialize(pd, saf); } //setPercentDevice(pd); resetNewSampleCount(); }
  virtual ~AccelStrategy_PercentDevice() { }

  virtual int getStrategyType() { return ACCEL_STRATEGY_PERCENT_DEVICE; }

  virtual AccelError decide(int funcIndex,
                            AEMRecord *record,
                            AccelDecision &decision,
                            void *objPtr,
                            AccelManager* manager
                           );

  virtual void periodicSample(double value, AccelManager *manager) { incrementNewSampleCount(manager); }

  virtual void notifyLBFinished();

  void setPercentDevice(float pd) {
    if (pd < 0.0f || pd > 1.0f) { return; }
    percentDevice = pd;

    // DMK - DEBUG
    printf("[ACCELMGR] :: PE %d :: new percent device = %f @ time %lf ...\n",
           CkMyPe(), percentDevice, CkWallTimer()
          );
  }

  virtual void* allocStrategyVars() {
    Variables *vars = new Variables;
    vars->percentDevice = percentDevice;
    vars->deviceCount = 0;
    vars->hostCount = 0;
    vars->deviceTarget = -1;
    vars->hostTarget = -1;
    vars->assigningFlag = 1;
    return vars;
  }
  virtual void freeStrategyVars(void *vars) {
      if (vars != NULL) { delete ((Variables*)vars); }
  }

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: %f Percent Device (%s ASSIGN)\n", CkMyPe(), percentDevice, ((staticAssignFlag) ? ("STATIC") : ("DYNAMIC")));
  };

  void setStaticMode(int saf) { staticAssignFlag = ((saf) ? (1) : (0)); }
  int getStaticMode() { return staticAssignFlag; }
};


class AccelStrategy_Step : public AccelStrategy_PercentDevice {

 protected:

  float stepSize;
  int newSampleCount;

 public:

  AccelStrategy_Step() { stepSize = ACCEL_STRATEGY_ADJUST_STEP_STEPSIZE; newSampleCount = 0; }
  AccelStrategy_Step(float ss) { stepSize = ss; newSampleCount = 0; }
  virtual ~AccelStrategy_Step() { }

  virtual int getStrategyType() { return ACCEL_STRATEGY_STEP; }

  virtual void periodicSample(double value, AccelManager *manager) { newSampleCount++; }

  virtual void notifyIdle(AccelManager *manager);

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: STEP - stepSize = %lf%s\n", CkMyPe(), stepSize, ((getStaticMode()) ? (" (STATIC ASSIGN") : ("")));
  }
};


class AccelStrategy_AdjustBusy : public AccelStrategy_PercentDevice {

 public:

  AccelStrategy_AdjustBusy() { }
  virtual ~AccelStrategy_AdjustBusy() { }

  virtual int getStrategyType() { return ACCEL_STRATEGY_ADJUST_BUSY; }

  virtual void notifyIdle(AccelManager *manager);

  virtual void notifyLBFinished() { }

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: ADJUST BUSY\n", CkMyPe());
  }
};


class AccelStrategy_Sampling : public AccelStrategy_PercentDevice {

 private:

  int isCentral;
  float percentDeviceBias ;

  double *sample;
  double *sampleAvg;
  int *sampleCount;

  float percentDevice_pending[ACCELMGR_PERCENT_DEVICE_PENDING_LEN];
  int percentDevice_pendingLen;

  void initialize(int centralFlag = 0, float percentDeviceBias = 0.0f);
  void cleanup();

  void resetData();

 public:

  AccelStrategy_Sampling() { initialize(); }
  AccelStrategy_Sampling(int centralFlag) { initialize(centralFlag); }
  AccelStrategy_Sampling(int centralFlag, float percentDeviceBias) { initialize(centralFlag, percentDeviceBias); }
  virtual ~AccelStrategy_Sampling() { cleanup(); }

  virtual int getStrategyType() { return ACCEL_STRATEGY_SAMPLING; }

  virtual void notifyIdle(AccelManager *manager);
  virtual void periodicSample(double value, AccelManager *manager);

  virtual void notifyLBFinished();

  virtual int isCentralized() { return isCentral; }

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: SAMPLING%s - Bias: %f\n",
           CkMyPe(), ((isCentral) ? (" (Centralized)") : ("")), percentDeviceBias
          );
  }
};


class AccelStrategy_Profiler : public AccelStrategy {

 private:

  struct Variables {
    double hostTime;
    double kernelTime;
    int hostTimeCount;
    int kernelTimeCount;
  };

  int numRotations;
  int waitingForRestart;
  int activeFuncIndex;
  int newSampleCount;

  void initialize() {
    numRotations = 0;
    waitingForRestart = 1;
    activeFuncIndex = 0;
    newSampleCount = 0;
  }

  void controlActiveFuncIndex(AccelManager *manager, AEMRecord *record);

  void printProfileData(AccelManager *manager, FILE *fout = stdout);

 public:

  AccelStrategy_Profiler() { initialize(); }
  virtual ~AccelStrategy_Profiler() { }

  virtual int getStrategyType() { return ACCEL_STRATEGY_PROFILER; }

  virtual AccelError decide(int funcIndex,
                            AEMRecord *record,
                            AccelDecision &decision,
                            void *objPtr,
                            AccelManager* manager
                           );

  virtual void userHostCodeTiming(AEMRecord *record, double startTime, double endTime) {
    Variables *vars = (Variables*)(record->strategyVars);
    if (vars == NULL) { return; }
    vars->hostTime += (endTime - startTime);
    vars->hostTimeCount += 1;
  }

  virtual void* allocStrategyVars() {
    Variables *vars = new Variables;
    vars->hostTime = 0.0;
    vars->kernelTime = 0.0;
    vars->hostTimeCount = 0;
    vars->kernelTimeCount = 0;
    return (void*)vars;
  }
  virtual void freeStrategyVars(void* vars) {
    if (vars != NULL) { delete ((Variables*)vars); }
  }

  virtual int isSafeToRemove() {
    return ((waitingForRestart == 1 && activeFuncIndex == -1) ? (1) : (0));
  }
  virtual void aboutToRemove(AccelManager *manager);

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: PROFILER\n", CkMyPe());
  }
};


class AccelStrategy_BaseLoadProfiler : public AccelStrategy {

 private:

  struct Variables {
    int samplingStarted;
    int numSamples;
    int pendingStop;
  };

  // DMK - NOTE | TODO - There are more variables being used here than really required, so
  //   come back and try to reduce the number of counters and flags being used by this class
  int numStarted;
  int allStarted;
  int numFinished;
  int numStopped;
  int allStopped;
  double baseLoad;
  double baseLoadOverlapped;
  double periodicSampleSum;
  int periodicSampleCount;

  void initialize() {
    numStarted = 0;
    allStarted = 0;
    numFinished = 0;
    numStopped = 0;
    allStopped = 0;
    baseLoad = -1.0;
    baseLoadOverlapped = -1.0;
    periodicSampleSum = 0.0;
    periodicSampleCount = 0;
  }

  void takeSample(AccelManager *manager, AEMRecord *record);

 public:

  AccelStrategy_BaseLoadProfiler() { initialize(); }
  virtual ~AccelStrategy_BaseLoadProfiler() { }

  virtual int getStrategyType() { return ACCEL_STRATEGY_BASE_LOAD_PROFILER; }

  virtual AccelError decide(int funcIndex,
                            AEMRecord *record,
                            AccelDecision &decision,
                            void *objPtr,
                            AccelManager* manager
                           );

  virtual void periodicSample(double value, AccelManager *manager);

  virtual void* allocStrategyVars() {
    Variables *vars = new Variables;
    vars->samplingStarted = 0;
    vars->numSamples = 0;
    vars->pendingStop = 0;
    return (void*)vars;
  }
  virtual void freeStrategyVars(void *vars) {
    if (vars != NULL) { delete ((Variables*)vars); }
  }

  virtual int isSafeToRemove() { return allStopped; }
  virtual void aboutToRemove(AccelManager *manager);

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: BASE LOAD PROFILER\n", CkMyPe());
  }
};


class AccelStrategy_Greedy : public AccelStrategy {

 private:

  struct Variables {
    float percentDevice;
    float percentDevice_pending;
    int appliedFlag;
  };

  int percentsSet;
  int numPercentsApplied;
  int numPercentsToApply;

  void initialize() {
    percentsSet = 0;
    numPercentsApplied = 0;
    numPercentsToApply = 0;
  }

  void defaultPercents(AccelManager *manager);
  void calculatePercents(AccelManager *manager);

 public:

  AccelStrategy_Greedy() { percentsSet = 0; numPercentsApplied = 0; }
  virtual ~AccelStrategy_Greedy() { }

  virtual int getStrategyType() { return ACCEL_STRATEGY_GREEDY; }

  virtual AccelError decide(int funcIndex,
                            AEMRecord *record,
                            AccelDecision &decision,
                            void *objPtr,
                            AccelManager* manager
                           );

  virtual void* allocStrategyVars() {
    Variables *vars = new Variables;
    vars->percentDevice = 0.0f;
    vars->percentDevice_pending = 0.0f;
    vars->appliedFlag = 0;
    return (void*)vars;
  }
  virtual void freeStrategyVars(void *vars) {
    delete ((Variables*)vars);
  }

  virtual int isSafeToRemove() { return (numPercentsApplied >= numPercentsToApply); }
  virtual void aboutToAdd(AccelManager *manager) { calculatePercents(manager); }

  virtual int isPercentDevicePassable() { return 1; }
  virtual float getPassedPercentDevice(AEMRecord *record);

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: GREEDY\n", CkMyPe());
  }
};


class AccelStrategy_Crawler : public AccelStrategy {

 protected:

  struct Variables {
    float percentDevice;
    float percentDeviceBase;
    float percentDeviceOffset;
  };

 public:

  AccelStrategy_Crawler() { }
  virtual ~AccelStrategy_Crawler() { }

  virtual int getStrategyType() = 0;

  virtual AccelError decide(int funcIndex,
                            AEMRecord *record,
                            AccelDecision &decision,
                            void *objPtr,
                            AccelManager* manager
                           );

  virtual void* allocStrategyVars() {
    Variables* vars = new Variables;
    vars->percentDevice = 1.0f;
    vars->percentDeviceBase = 1.0f;
    vars->percentDeviceOffset = 0.0f;
    return (void*)vars;
  }
  virtual void freeStrategyVars(void *vars) { delete ((Variables*)vars); }

  virtual int acceptsPercentDevicePassable() { return 1; }
  virtual void setPassedPercentDevice(AEMRecord *record, float pd) {
    Variables *vars = (Variables*)(record->strategyVars);
    if (vars == NULL) { return; }
    vars->percentDevice = pd;
    vars->percentDeviceBase = pd;
    vars->percentDeviceOffset = 0.0f;
  }

  void applyNewOffsets(AccelManager *manager, float numFuncIndexes, float *offset);

  virtual void printConfig(FILE *fout = stdout) = 0;
};

class AccelStrategy_Crawler_Master : public AccelStrategy_Crawler {

 private:

  int numSamples;
  float sampleAccum;

  float *currentOffsets;  // Offsets we use to "look around"
  float *accumOffsets;    // Summing of "winning moves"

  int rotationLen;
  int rotationIndex;
  float *sampleAvg;

  float stepSize;

  void initialize(AccelManager *manager);
  void cleanup();

  // NOTE: Since offset = 0 when rotation index = 0, the return value
  //   of calcFuncIndex can be 0 when ri = 0 (it won't do anything)
  int calcFuncIndex(int ri) { return ((ri == 0) ? (0) : ((ri - 1) / 2)); }
  float calcOffset(int ri) {
    if (ri == 0) { return 0.0f; }
    float base = stepSize;
    float sign = 1.0f;
    if ((ri - 1) % 2) { sign = -1.0f; }
    return base * sign;
  }

 public:

  AccelStrategy_Crawler_Master() { }
  virtual ~AccelStrategy_Crawler_Master() { cleanup(); }

  virtual int getStrategyType() { return ACCEL_STRATEGY_CRAWLER_MASTER; }

  virtual AccelError decide(int funcIndex,
                            AEMRecord *record,
                            AccelDecision &decision,
                            void *objPtr,
                            AccelManager* manager
                           );

  virtual void periodicSample(double value, AccelManager *manager) {
    if (numSamples >= 0) { sampleAccum += value; } // Negative values cause skipping of initial samples
    numSamples++;
  }

  virtual void aboutToAdd(AccelManager *manager) { initialize(manager); }

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: CRAWLER MASTER\n", CkMyPe());
  }
};

class AccelStrategy_Crawler_Slave : public AccelStrategy_Crawler {

 private:

 public:

  AccelStrategy_Crawler_Slave() {  }
  virtual ~AccelStrategy_Crawler_Slave() { }

  virtual int getStrategyType() { return ACCEL_STRATEGY_CRAWLER_SLAVE; }

  virtual void printConfig(FILE *fout = stdout) {
    printf("[ACCEL-STRATEGY] :: PE %d :: CRAWLER SLAVE\n", CkMyPe());
  }
};

class AccelPersistBuffer {

 private:

  void *objPtr;
  void *hostBufPtr;
  void *deviceBufPtr;
  int size;
  int isDeviceDirty;
  int isHostDirty;

  void initialize(void *oPtr, void *hPtr, int s);
  void cleanup();

 public:

  AccelPersistBuffer(void *oPtr, void *hPtr, int s);
  ~AccelPersistBuffer();

  void *getObjectPtr() { return objPtr; }
  void *getHostBuffer() { return hostBufPtr; }
  void *getDeviceBuffer() { return deviceBufPtr; }
  int getSize() { return size; }

  void pushToDevice();
  void pullFromDevice();

  void markDataAsOnDevice() { isDeviceDirty = 0; isHostDirty = 1; }
  void markDataAsOnHost() { isDeviceDirty = 1; isHostDirty = 0; }
};


#define ACCEL_OBJECT_DATA_INIT_PERSIST_ARRAY_LEN   (8)
#define ACCEL_OBJECT_DATA_GROW_PERSIST_ARRAY_LEN   (8)

typedef enum __object_data_location {
  ACCEL_OBJECT_DATA_LOCATION_UNSET = -1,
  ACCEL_OBJECT_DATA_LOCATION_HOST,
  ACCEL_OBJECT_DATA_LOCATION_DEVICE
} AccelObjectDataLocation;

typedef struct _accel_object_data {

  void *objectPtr;

  void **persistHostPtr;
  int persistHostPtr_len;
  int persistHostPtr_maxLen;

  AccelObjectDataLocation location;

} AccelObjectData;

class AccelManager {

 private:

  #if CMK_ACCEL_SMP != 0
    // DMK - FIXME | TODO - To do this properly, a lock needs to be created prior to threads
    //   splitting in converse.  However, ckaccel.h is a Charm++ level file, so including it
    //   will cause issues during complication... for now, just to test if it helps, declare
    //   an array with a static length to avoid the need for a lock... if it helps, fix this
    //   and related code to do this properly.
    //static AccelManager **accelManager;
    static AccelManager *accelManager[64];
  #else
    static AccelManager *accelManager;
  #endif

  // NOTE : The function indexes (funcIndex) of the accelerated entry methods
  // start at 0 and increment by 1 for each unique AEM, so the use of a dense
  // array to store records by funcIndex should not waste much, if any, memory
  // unless the programmer is going out of their way cause it.
  AEMRecord** recordList;
  int recordListLen;
  AccelError growRecordListToInclude(int funcIndex);
  AccelError initializeRecord(int funcIndex);

  // Keep track of the number of each device type available
  int numDevices[ACCEL_NUM_DEVICE_TYPES];

  AccelStrategy *strategy;
  std::list<AccelStrategy*> *pendingStrategies;

  double baseLoad;
  double baseLoadOverlapped;

  // Idle time measurement
  double idleTime[5];   // NOTE: index 0 = busy time, index 1 = idle time
  double lastIdleNotifyTime;
  int lastIdleNotifyType;
  double lastIdleAdjustmentTime;

  int conditionIndex[5];

  int flags;
  double periodicSample_previousValue;

  std::list<AccelCallbackStruct*> *callbackStructList;
  std::list<AccelCallbackStruct*> *pendingCallbackStructList;

  //int hostOnlyFlag;

  double kernelTime[2];
  double lastKernelTime;
  int activeKernelCount;

  //AccelError setStrategy(AEMRecord *rec, AccelStrategyType strategyType);
  //AccelError cleanupStrategy(AEMRecord *rec);

  void initialize();
  void cleanup();


  // Persistant buffers
  // DMK - NOTE | TODO - Using a map for now, but a hash table would be a better solution
  std::map<void*,AccelPersistBuffer*> *persistMap;
  void abandonPersistData();
  void cleanAbandonedPersistData();

  // Object data
  std::map<void*,AccelObjectData*> *objectMap;
  void removeAllObjectData();
  void removeObjectData(void *objectPtr);
  void registerPersistHostBufferWithObject(void *objectPtr, void *hostPtr);
  void unregisterPersistHostBufferWithObject(void *objectPtr, void *hostPtr);

  // DMK - NOTE | TODO - Using a map for now, but a hash table would be a better solution
  std::map<void*,int> *locMgrMap;

  // Delayed host calls
  std::list<AccelDelayCallData*> *delayCallDataStructs;

  int numAbandonedRequests;
  std::list<AccelPersistBuffer*> *abandonedPersistBuffers;
  void abandonPendingRequests();

  double takePeriodicSample_prevTime;

 public:

  AccelManager();
  ~AccelManager();

  static AccelManager* getAccelManager();
  static void destroyAccelManager();

  AccelError setDeviceCount(AccelDeviceType deviceType, int deviceCount);
  int getDeviceCount(AccelDeviceType deviceType);

  AccelStrategy* getStrategy() { return strategy; }
  AccelError decide(int funcIndex,
                    int checkInCount, int numLocalElements,
                    int isTriggered, int isSplittable,
                    AccelDecision &decision,
                    void *objPtr
                   );

  // Performance measuring mechanism/interface
  void setAutoMeasurePerf(int flag) {
    if (flag) {
      flags |= ACCELMGR_FLAGMASK_AUTO_MEASURE_PERF;
    } else {
      flags &= (~ACCELMGR_FLAGMASK_AUTO_MEASURE_PERF);
    }
  }
  int getAutoMeasurePerf() { return flags & ACCELMGR_FLAGMASK_AUTO_MEASURE_PERF; }

  // Performance measuring for kernels
  void markKernelStart();
  void markKernelEnd();
  void resetKernelTime();
  double getKernelBusyTime();
  double getKernelIdleTime();

  void setBaseLoad(double bl) { baseLoad = bl; }
  double getBaseLoad() { return baseLoad; }
  void setBaseLoadOverlapped(double blo) { baseLoadOverlapped = blo; }
  double getBaseLoadOverlapped() { return baseLoadOverlapped; }

  // Idle/busy time measuring for host
  void notify_idle(int type, double time);
  void resetHostTime();
  double getHostIdleTime();
  double getHostBusyTime();
  double getHostCallbackAdjustTime();
  double getHostOverlappedBusyTime();
  double getHostOverlappedIdleTime();
  void adjustCallbackTime(double ammount);

  // Periodic sampling
  void takePeriodicSample(double value = -1.0);

  // Notifcation from the load balancing framework that load balancing has just finished
  void notifyLBFinished();
  void notifyFlushAccel();
  void notifyAbandonedRequestCompletion(AccelCallbackStruct *cbStruct);

  // Host timing data
  AccelError userHostCodeTiming(int funcIndex, double startTime, double endTime);

  int getNumFuncIndexes() { return recordListLen; }
  AEMRecord* getFuncIndexRecord(int funcIndex) {
    if (funcIndex < 0 || funcIndex >= recordListLen) { return NULL; }
    return recordList[funcIndex];
  }

  // Pool for callback structures
  AccelCallbackStruct* allocAccelCallbackStruct();
  void resetAccelCallbackStruct(AccelCallbackStruct *cbStruct);
  void freeAccelCallbackStruct(AccelCallbackStruct *cbStruct);
  void updateLastContribTime(AccelCallbackStruct *cbStruct);
  void submitPendingRequests();
  void submitPendingRequest(AccelCallbackStruct*);
  AccelCallbackStruct* getCurrentCallbackStruct(int funcIndex);
  void setCurrentCallbackStruct(int funcIndex, AccelCallbackStruct *cbStruct);

  void notifyPeriodic(double time);
  void notifyPeriodic_5m(double time);

  // Persistant buffers
  // NOTE: new and delete functions also push and pull the data, respectively
  AccelPersistBuffer* newPersistBuffer(void *oPtr, void *hPtr, int size);
  AccelPersistBuffer* getPersistBuffer(void *hPtr);
  void pullPersistBuffer(void *hPtr);
  void pushPersistBuffer(void *hPtr);
  void deletePersistBuffer(AccelPersistBuffer *persistBuf);

  // Object data
  AccelObjectData* getObjectData(void *objectPtr);
  void notifyObjectIsPacking(void *objectPtr);
  void pullObjectData(void *objectPtr);
  void pushObjectData(void *objectPtr);
  void cleanStaleObjectData();

  void setPercentDevice(float pd);

  int numElementsLookup(CkLocMgr *locMgr);

  // Delayed host calls
  AccelError delayGeneralCall(AccelDelayCallData* dataPtr);
  void issueDelayedGeneralCalls(int funcIndex);
  AccelDelayCallData* allocAccelDelayCallData();
  void freeAccelDelayCallData(AccelDelayCallData *ptr);
};


class AccelManagerGroup : public CBase_AccelManagerGroup {

 public:

  AccelManagerGroup();
  AccelManagerGroup(CkMigrateMessage *m);
  ~AccelManagerGroup();

  void strategyAdjustPerf_setPercentDevice(float pd);
  void accelStrategy_setPercentDevice(float pd);

  void accelStrategy_crawler_setOffsets(int numOffsets, float *offsets);

  void accelStrategy_notifyLBFinished();

  void shutdown();
  void shutdownCheckin();

  virtual void pup(PUP::er &p);

};


// Functions for printing a text string representation of a given
//   values (i.e. for use with printf to print human readable messages)
extern const char * const accelErrorString(AccelError err);
extern const char * const accelIssueFlagString(AccelIssueFlag aif);
extern const char * const accelDeviceTypeString(AccelDeviceType dt);

// Callback functions related to Ccd Conditions
void accelMgr_beginIdle_callback(void *arg, double time);
void accelMgr_endIdle_callback(void *arg, double time);
void accelMgr_periodic_1s_callback(void *arg, double time);
void accelMgr_periodic_callback(void *arg, double time);
void accelMgr_periodic_5m_callback(void *arg, double time);

// Function to be called to trigger AccelManager cleanup
extern "C" void initAccelManager();
extern "C" void exitAccelManager();

#if CMK_CUDA != 0
  extern "C" void gpuProgressFn();
#endif


#endif //__CK_ACCEL_H__
